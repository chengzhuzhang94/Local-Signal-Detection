function [sep_count, cover_count, width_records, LBM_outloop] = CZ_BootstrapCR_logistic(seed, m_star_sep, m_star_s1, m_star_s2, TRI, pv, n, nc, vx, vy, d, nv, v1, v2, v3, e1, e2, e3, ie1, m, kLoopTime, option1, option2, optionLU, outloopTimes, boots_lam_vec)
% Purpose:
% This function calculate coverage probability for binary response
% simulation

% Arguments:
% seed: random seed
% n: sample size
% kLoopTime: the number of inner loop that used to calculate one pair of LPR and UPR
% outloopTimes: the number of outer loop, in which LPR and UPR would be checked with true zero regions bounds
% option1: indicator of which type of Bootstrap is used. The default value is 1
% option2: indicator of whether using tuned hyperparmeter "a" in SCAD penalty

% optionLU: indicator of how to compare MCR and true zero region. 1 means we use same region as true
% zero region to compare with MCR, 2 means we use m_star_s2 to compare with UBM and m_star_s1 to
% compare with LBM. Based on the paper, number 2 is the default comparison option
 
% (a, a_tune): tuning hyperparameters
% (m_star_sep, m_star_s1, m_star_s2): lower bound and upper bound regions for true zero regions for each varying coefficient
% (TRI,v1,v2,v3,nt,nc,nv,d): these are associated values of Triangulation TRI. (v1,v2,v3,nt,nc,nv,d)are generated by calling trilist()

% varying coefficients are fixed
f0 = @(x, y) -1.5  -3 .* abs( (-75-x)/17 - 0.3)  - 0.5 .* sin(1.5*pi .* (y-29)/10 ) ;
f1 = @(x,y) 2.*(exp( 2.*((-75-x)/17 -0.3) .* ((-75-x)/17>0.3) - ((-75-x)/17 -0.7) .* ((-75-x)/17>0.7) ) - 1)  ;
f2 = @(x, y) 0.*y; m=3;

rng(seed); nt = size(TRI, 1);

cover_count = 0; sep_count = zeros(outloopTimes, m);
bound_diff = zeros(outloopTimes, 2);
LBM_outloop = cell(outloopTimes, 2); LBMUBM_outloop = cell(outloopTimes, 2);
width_records=zeros(outloopTimes,m);

for outloop=1:outloopTimes
    % for each outer loop, we need to generate new data points
    count = 1; S_1 = zeros(n, 1); S_2 = zeros(n, 1);
   while count <= n+10
       temp = [22.*rand(1,1)-94 12.*rand(1,1)+28]; 
       if inpolygon(temp(1), temp(2), pv(:,1), pv(:,2))
           S_1(count) = temp(1); S_2(count) = temp(2); count = count + 1;
       end
   end % Generate sample points' location
   X_1 = 1 .* (rand(n+10, 1) ); X_2 = 1 .* (rand(n+10, 1) ); % Set the distributions of X_1 and X_2 are same `Uniform distribution`
   Z = cal_probs(f0(S_1, S_2) + X_1 .* f1(S_1, S_2) + X_2 .* f2(S_1, S_2)); 
   Z = binornd(1, Z); ori_Z = Z;
  [B, valid_id] = CZ_SPL_est(S_1,S_2,vx,vy,TRI,v1,v2,v3,nt,nc,nv,d);  % grid_valid_id is based on left valid grid points
    valid_id = valid_id(1:n);
    
    mat_Z = zeros(n, m*nc);
  for k = valid_id
      temp1 = (B(k, :).* 1);temp2 = (B(k, :).* X_1(k,1));temp3 = (B(k, :).* X_2(k,1));
      temp = [temp1, temp2, temp3];mat_Z(k,:) = temp;
  end
  mat_Z = mat_Z(valid_id, :); Z = ori_Z(valid_id); %fprintf('Actual training design matrix size: %d * %d\n', size(mat_Z));
  [b_hat dev stats] = glmfit(mat_Z, Z, 'binomial', 'link', 'logit', 'constant', 'off'); % Default iteration times is 100
 
    nlam = 14; a = 3.7;threshold = 10 ^ (-3); lam_vec = linspace(0.35, 1, nlam);
      % Use BIC again to detect the best lambda value
      bic = zeros(nlam, 3); converged_or_not = zeros(nlam, 1);
      for q = 1:nlam         
            [p_b_hat, dist_logical, probs, first_deri_l, second_deri_l, Dgn, accuracy_record] = update_p_b_hat_logistic_NoC(...
                mat_Z, Z, b_hat, threshold, lam_vec(q), a, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 20, n, 1);
            converged_or_not(q) = dist_logical;
            preds = cal_probs(mat_Z * p_b_hat);
            preds_valid = setdiff(setdiff(1:1:length(valid_id), find(Z==1 & preds==1)), find(Z==0 & preds==0)) ; 
            bic(q, 1) =  -2*sum(Z(preds_valid).*log(preds(preds_valid))) - 2*sum((1-Z(preds_valid)).*log(1-preds(preds_valid))) + log(n) * sum(p_b_hat ~= 0);
            bic(q, 2) =  -2*sum(Z(preds_valid).*log(preds(preds_valid))) - 2*sum((1-Z(preds_valid)).*log(1-preds(preds_valid))) ;
            bic(q, 3) =  log(n) * sum(p_b_hat ~= 0); 
      end
      [temp_min, temp_index] = min(bic(:, 1));lam_vec(temp_index);      
      [p_b_hat, dist_logical, probs, first_deri_l, second_deri_l, Dgn, accuracy_record] = update_p_b_hat_logistic_NoC(...
        mat_Z, Z, b_hat, threshold, lam_vec(temp_index), a, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 20, n, 1); 
    
    % call another function to implement Bootstrapping to get MCR
    disp(['The Bootstrap of iteration: ', num2str(outloop), '-th inner loop started'])
    [records, lambda_records] = CZ_bootstrap_logic_nested(2, TRI, pv, vx, vy, n, mat_Z, Z, b_hat, p_b_hat, nt, nc, nv, d, v1, v2, v3, e1, e2, e3, ie1, m, kLoopTime, option1, option2, lam_vec(temp_index), boots_lam_vec);
    
    MCR_records = cell(size(records,1)+1, 2*m); CR_records = zeros(size(records,2)/m+1, m);
    for i = 1:m
        TRI_no = 1+(i-1)*nt:i*nt; [out, pi_idx] = sort(sum(records(:, TRI_no), 1), 'descend');   
        for w = 0:1:nt
            cr = 0; LBM = []; UBM = [];
            for k = 0:1:nt-w
                temp_LBM = pi_idx(1:k); temp_UBM = sort(pi_idx(1:k+w));
                temp_cr = CZ_CoverageRate(records(:, TRI_no), temp_LBM, temp_UBM);
                if temp_cr > cr
                    cr = temp_cr; LBM = temp_LBM; UBM = temp_UBM; 
                end
            end
            MCR_records{w+1, 2*i-1} = sort(LBM); MCR_records{w+1, 2*i} = sort(UBM); CR_records(w+1, i) = cr;
        end
    end

    width_records(outloop,1)= find(CR_records(:,1) > 0.95, 1)-1; width_records(outloop,2)= find(CR_records(:,2) > 0.95, 1)-1; width_records(outloop,3)= find(CR_records(:,3) > 0.95, 1)-1;
    
    % calculate for this outer loop, whether true zero region bounds are covered by LBM and UBM
    for i = 1:m
        LBM = sort(MCR_records{find(CR_records(:,i) > 0.95,1), 2*i-1}) ; UBM = sort(MCR_records{find(CR_records(:,i) > 0.95,1), 2*i}) ;        
        if optionLU == 1
            if all(ismember(LBM, m_star_sep{i,1})) && all(ismember(m_star_sep{i,1}, UBM))
                sep_count(outloop, i) = 1;
            end
        elseif optionLU == 2
            if all(ismember(LBM, m_star_s1{i,1})) && all(ismember(m_star_s2{i,1}, UBM))
                sep_count(outloop, i) = 1;
            end
        end        
    end
    % find LBM & UBM by using 0.95 as threshold
    LBM = [sort(MCR_records{find(CR_records(:,1) > 0.95,1), 2*1-1}) nt+sort(MCR_records{find(CR_records(:,2) > 0.95,1), 2*2-1}) 2*nt+sort(MCR_records{find(CR_records(:,3) > 0.95,1), 2*3-1})]; 
    UBM = [sort(MCR_records{find(CR_records(:,1) > 0.95,1), 2*1}) nt+sort(MCR_records{find(CR_records(:,2) > 0.95,1), 2*2}) 2*nt+sort(MCR_records{find(CR_records(:,3) > 0.95,1), 2*3})];
    
    % record LBM, UBM, bound diff
    LBMUBM_outloop{outloop, 1} = LBM; 
    LBMUBM_outloop{outloop, 2} = UBM; 
    m_star = [m_star_sep{2,1}+nt 2*nt+1:3*nt];
    bound_diff(outloop,1) = length(LBM) - sum(ismember(LBM, m_star)); 
    bound_diff(outloop, 2) = length(m_star) - sum(ismember(m_star, UBM));
    LBM_outloop{outloop,1}=setdiff(LBM, m_star, 'stable') - nt;
    LBM_outloop{outloop,2}=setdiff(m_star, UBM, 'stable') - nt;
    
    % determine whether it is covered depending on "optionLU"
    if optionLU == 1
        if all(ismember(LBM, m_star)) && all(ismember(m_star, UBM))
            cover_count = cover_count + 1;
        end
    elseif optionLU == 2
        if all(ismember(LBM, [m_star_s1{2,1}+nt 2*nt+1:3*nt])) && all(ismember([m_star_s2{2,1}+nt 2*nt+1:3*nt], UBM))
            cover_count = cover_count + 1; 
        end
        LBM_outloop{outloop,1}=setdiff(LBM, [m_star_s1{2,1}+nt 2*nt+1:3*nt], 'stable') - nt;
        LBM_outloop{outloop,2}=setdiff([m_star_s2{2,1}+nt 2*nt+1:3*nt], UBM, 'stable') - nt;
    end
     
    % Display current iteration results
    disp(['Iteration: ', num2str(outloop), ' finished and accumulative sum: ', num2str(sum(sep_count))])
end

end