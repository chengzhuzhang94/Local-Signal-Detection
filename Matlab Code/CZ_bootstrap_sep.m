function [records, lambda_records] = CZ_bootstrap_sep(seed, TRI, mat_Z, Z, n, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, m, kLoopTime, option1, option2, a, a_tune)
% Purpose:
% This function generates records of estimated zero triangles via Bootstrapping for one dataset
% This function applies Bootstrap on varying coefficient functions separately, and that is why we
% call "CZ_bootstrap()" internally

% Arguments:
% seed: random seed
% mat_Z: original design matrix
% Z: original response variable
% n: sample size
% kLoopTime: the number of inner loop that used to calculate one pair of LPR and UPR
% option1: indicator of which type of Bootstrap is used. The default value is 1
% option2: indicator of whether using tuned hyperparmeter "a" in SCAD penalty
% (a, a_tune): tuning hyperparameters
% (m_star_sep, m_star_s1, m_star_s2): lower bound and upper bound regions for true zero regions for each varying coefficient
% (TRI,v1,v2,v3,nt,nc,nv,d): these are associated values of Triangulation TRI. (v1,v2,v3,nt,nc,nv,d)are generated by calling trilist()

nt = size(TRI, 1);
b_hat = (transpose(mat_Z) * mat_Z + 1 / (log(n)*nt) * eye(m*nc)) \ transpose(mat_Z) * Z;
nlam = 40;threshold = 10 ^ (-3);
lam_vec = linspace(0.01, 0.4, nlam);
bic = zeros(nlam, 1); converged_or_not = zeros(1, nlam);
for q = 1:nlam
    [p_b_hat, dist_logical] = update_p_b_hat_2(mat_Z, Z, b_hat, threshold, lam_vec(q), a, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 300, n,2,1);
    converged_or_not(q) = dist_logical; 
    bic(q) = log(mean((Z - mat_Z * p_b_hat).^2)) + log(n) * sum(p_b_hat ~=0) / n;
end
[temp_min, temp_index] = min(bic); fitted_lambda=lam_vec(temp_index) ;

if option2 ~= 3
    [p_b_hat, dist_logical] = update_p_b_hat_2(mat_Z, Z, b_hat, threshold, lam_vec(temp_index), a, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 300, n,2,1);
else
    [p_b_hat, dist_logical] = update_p_b_hat_2(mat_Z, Z, b_hat, threshold, lam_vec(temp_index), a-a_tune, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 300, n,2,1);
end
fixed_b_hat = b_hat; fixed_p_b_hat = p_b_hat ;
Sep_Z = zeros(m,n);
Res = zeros(m, n); Z_bootbase = zeros(m, n); 
records = zeros(kLoopTime, nt*m); lambda_records = zeros(m, kLoopTime);

if option1 == 1
    for i = 1:m
        % The i-th varying function's coefficients are set as 0s
        temp_p_b_hat = fixed_p_b_hat; temp_p_b_hat((i-1)*nc+1:i*nc) = 0; 
        temp_Z = Z - mat_Z * temp_p_b_hat; temp_esti_b_hat = (transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * mat_Z(:,(i-1)*nc+1:i*nc) + 1 / (log(n)*nt) * eye(nc)) \ transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * temp_Z;
        Sep_Z(i, :) = temp_Z; 
        Res(i, :) = temp_Z - mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;  Z_bootbase(i, :) = mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;
    end
elseif option1 == 2
    for i = 1:m
        temp_b_hat = fixed_b_hat; temp_b_hat((i-1)*nc+1:i*nc) = 0; 
        temp_Z = Z - mat_Z * temp_b_hat; temp_esti_b_hat = (transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * mat_Z(:,(i-1)*nc+1:i*nc) + 1 / (log(n)*nt) * eye(nc)) \ transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * temp_Z;
        Sep_Z(i, :) = temp_Z;Res(i, :) = temp_Z - mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;  Z_bootbase(i, :) = mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;
    end
elseif option1 == 0
    for i = 1:m
        temp_p_b_hat = fixed_p_b_hat; temp_p_b_hat((i-1)*nc+1:i*nc) = 0; 
        temp_Z = Z - mat_Z * temp_p_b_hat; temp_esti_b_hat = (transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * mat_Z(:,(i-1)*nc+1:i*nc) + 1 / (log(n)*nt) * eye(nc)) \ transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * temp_Z;
        Sep_Z(i, :) = temp_Z;
        Res(i, :) = temp_Z - mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;  Z_bootbase(i, :) = mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat; Res(i, :) = Res(i, :) - mean(Res(i, :));
    end  
end

if seed ~= 0
    rng(seed);
end

for i = 1:m

    temp_Z = transpose(Sep_Z(i, :)); temp_mat_Z = mat_Z(:, (i-1)*nc+1:i*nc);
    
    [temp_records temp_lambda_records] = CZ_bootstrap(0, TRI, temp_mat_Z, temp_Z, n, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, 1, kLoopTime, option1, option2, a, a_tune);

    records(:, (i-1)*nt+1:i*nt) = temp_records; lambda_records(i, :) = temp_lambda_records;
end
end