function [records, lambda_records] = CZ_bootstrap_sep_customized(seed, lower, upper, nlam, cols_output, TRI, mat_Z, Z, n, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, m, kLoopTime, option1, option2, a, a_tune)
% Purpose:
% This function is an alternative version of "CZ_bootstrap_sep"

% Arguments:
% seed: random seed
% (lower, upper): the lower and upper bounds for lambda in SCAD penalty (hyperparameter)
% mat_Z: original design matrix
% Z: original response variable
% n: sample size
% kLoopTime: the number of inner loop that used to calculate one pair of LPR and UPR
% option1: indicator of which type of Bootstrap is used. The default value is 1
% option2: indicator of whether using tuned hyperparmeter "a" in SCAD penalty
% (a, a_tune): tuning hyperparameters
% (m_star_sep, m_star_s1, m_star_s2): lower bound and upper bound regions for true zero regions for each varying coefficient
% (TRI,v1,v2,v3,nt,nc,nv,d): these are associated values of Triangulation TRI. (v1,v2,v3,nt,nc,nv,d)are generated by calling trilist()

nt = size(TRI, 1);
b_hat = (transpose(mat_Z) * mat_Z + 1 / (log(n)*nt) * eye(m*nc)) \ transpose(mat_Z) * Z;
threshold = 10 ^ (-3);
lam_vec = linspace(lower, upper, nlam);
bic = zeros(nlam, 1); converged_or_not = zeros(1, nlam);
for q = 1:nlam
    [p_b_hat, dist_logical] = update_p_b_hat_2(mat_Z, Z, b_hat, threshold, lam_vec(q), a, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 300, n,2,1);
    converged_or_not(q) = dist_logical; p_b_hat(abs(p_b_hat)<0.00001) = 0;
    bic(q) = log(mean((Z - mat_Z * p_b_hat).^2)) + log(n) * sum(p_b_hat ~=0) / n;
end
[temp_min, temp_index] = min(bic); fitted_lambda=lam_vec(temp_index) ;

if option2 ~= 3
    [p_b_hat, dist_logical] = update_p_b_hat_2(mat_Z, Z, b_hat, threshold, lam_vec(temp_index), a, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 300, n,2,1);
else
    [p_b_hat, dist_logical] = update_p_b_hat_2(mat_Z, Z, b_hat, threshold, lam_vec(temp_index), a-a_tune, m, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, TRI, 300, n,2,1);
end

fixed_b_hat = b_hat; fixed_p_b_hat = p_b_hat ;
Sep_Z = zeros(length(cols_output),n);
Res = zeros(length(cols_output), n); Z_bootbase = zeros(length(cols_output), n); 
if option1 == 1
    for i = cols_output
        temp_p_b_hat = fixed_p_b_hat; temp_p_b_hat((i-1)*nc+1:i*nc) = 0; 
        temp_Z = Z - mat_Z * temp_p_b_hat; temp_esti_b_hat = (transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * mat_Z(:,(i-1)*nc+1:i*nc) + 1 / (log(n)*nt) * eye(nc)) \ transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * temp_Z;
        Sep_Z(i, :) = temp_Z;Res(i, :) = temp_Z - mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;  Z_bootbase(i, :) = mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;
    end
elseif option1 == 2
    for i = cols_output
        temp_b_hat = fixed_b_hat; temp_b_hat((i-1)*nc+1:i*nc) = 0; 
        temp_Z = Z - mat_Z * temp_b_hat; temp_esti_b_hat = (transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * mat_Z(:,(i-1)*nc+1:i*nc) + 1 / (log(n)*nt) * eye(nc)) \ transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * temp_Z;
        Sep_Z(i, :) = temp_Z;Res(i, :) = temp_Z - mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;  Z_bootbase(i, :) = mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;
    end
elseif option1 == 0
    for i = cols_output
        temp_p_b_hat = fixed_p_b_hat; temp_p_b_hat((i-1)*nc+1:i*nc) = 0; 
        temp_Z = Z - mat_Z * temp_p_b_hat; temp_esti_b_hat = (transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * mat_Z(:,(i-1)*nc+1:i*nc) + 1 / (log(n)*nt) * eye(nc)) \ transpose(mat_Z(:,(i-1)*nc+1:i*nc)) * temp_Z;
        Sep_Z(i, :) = temp_Z;
        Res(i, :) = temp_Z - mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat;  Z_bootbase(i, :) = mat_Z(:,(i-1)*nc+1:i*nc) * temp_esti_b_hat; Res(i, :) = Res(i, :) - mean(Res(i, :));
    end  
end

if seed ~= 0
    rng(seed);
end
records = zeros(kLoopTime, size(TRI,1)*m); lambda_records = zeros(m, kLoopTime);

for i = cols_output
    
    temp_Z = transpose(Sep_Z(i, :)); temp_mat_Z = mat_Z(:, (i-1)*nc+1:i*nc);

    [temp_records] = CZ_bootstrap_customized(0, lower, upper, nlam,TRI, temp_mat_Z, temp_Z, n, nc, d, nv, v1, v2, v3, e1, e2, e3, ie1, 1, kLoopTime, option1, option2, a, a_tune);

    records(:, (i-1)*nt+1:i*nt) = temp_records; 
end

end